// lib/services/cache_service.dart
import 'package:hive_flutter/hive_flutter.dart';
import 'package:path_provider/path_provider.dart';
import '../models/user_model.dart';
import '../models/message_model.dart';
import '../models/reaction_model.dart';
import '../models/conversation_model.dart';

class CacheService {
  // Box names for our database tables
  static const String conversationsBoxName = 'conversationsBox';
  static const String messagesBoxName = 'messagesBox';

  // Initializes the Hive database and registers the model adapters.
  // This must be called once when the app starts.
  static Future<void> init() async {
    final appDocumentDir = await getApplicationDocumentsDirectory();
    await Hive.initFlutter(appDocumentDir.path);

    // Registering the adapters generated by build_runner
    Hive.registerAdapter(UserAdapter());
    Hive.registerAdapter(ReactionAdapter());
    Hive.registerAdapter(MessageAdapter());
    Hive.registerAdapter(ConversationAdapter());

    // Open the boxes (like opening tables in a database)
    await Hive.openBox<Conversation>(conversationsBoxName);
    await Hive.openBox<Message>(messagesBoxName);
  }

  // --- Conversation Caching ---

  /// Saves a list of conversations to the local cache.
  /// It replaces any existing data with the new list.
  Future<void> saveConversations(List<Conversation> conversations) async {
    final box = Hive.box<Conversation>(conversationsBoxName);
    // Clear old data before saving new data to ensure consistency
    await box.clear();
    // Use a map for efficient storage, using the conversation ID as the key
    final Map<String, Conversation> conversationMap = {
      for (var convo in conversations) convo.id: convo,
    };
    await box.putAll(conversationMap);
  }

  /// Retrieves the list of cached conversations.
  List<Conversation> getConversations() {
    final box = Hive.box<Conversation>(conversationsBoxName);
    return box.values.toList();
  }

  // --- Message Caching ---

  /// Saves a list of messages for a specific conversation.
  /// Note: We use a unique key for each message to store them all in one box.
  Future<void> saveMessages(
    String conversationId,
    List<Message> messages,
  ) async {
    final box = Hive.box<Message>(messagesBoxName);
    final Map<String, Message> messagesMap = {
      // Create a unique key like "conversationId_messageId"
      for (var msg in messages) '${msg.conversationId}_${msg.id}': msg,
    };
    await box.putAll(messagesMap);
  }

  /// Retrieves all cached messages for a specific conversation.
  List<Message> getMessages(String conversationId) {
    final box = Hive.box<Message>(messagesBoxName);
    // Filter all messages in the box to get only the ones for this conversation
    return box.values
        .where((msg) => msg.conversationId == conversationId)
        .toList();
  }

  /// Adds or updates a single message in the cache.
  /// Useful for real-time updates.
  Future<void> addOrUpdateMessage(Message message) async {
    final box = Hive.box<Message>(messagesBoxName);
    await box.put('${message.conversationId}_${message.id}', message);
  }
}
